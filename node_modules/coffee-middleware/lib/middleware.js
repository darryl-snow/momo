/*!
 * cofee-script - middleware (adapted from the less-middleware)
 *
 * Original Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

var coffee = require('coffee-script'),
    fs = require('fs'),
    url = require('url'),
    path = require('path'),
    mkdirp = require('mkdirp');

/**
 * Return Connect middleware with the given `options`.
 *
 * Options:
 *
 *    `force`           Always re-compile
 *    `once`            Only re-compile the one time
 *    `debug`           Output debugging information
 *    `src`             Source directory used to find .coffee files
 *    `dest`            Destination directory used to output .js files
 *                      when undefined defaults to `src`.
 *    `prefix`          Path which should be stripped from `pathname`.
 *
 * Examples:
 *
 * Pass the middleware to Connect, grabbing .coffee files from this directory
 * and saving .js files to _./public_. Also supplying our custom `compile` function.
 *
 * Following that we have a `static` layer setup to serve the .js
 * files generated by Less.
 *
 *      var server = connect.createServer(
 *          coffee.middleware({
 *              src: __dirname + '/public'
 *          })
 *        , connect.static(__dirname + '/public')
 *      );
 *
 * @param {Object} options
 * @return {Function}
 * @api public
 */
module.exports = coffee.middleware = function(options){
  var regex = {
    handle: /\.js$/
  };

  options = options || {};

  // Accept src/dest dir
  if ('string' === typeof options) {
    options = { src: options };
  }

  // Only log if in debug mode
  var log = function(key, val, type) {
    if(options.debug || type === 'error') {
      switch(type) {
        case 'log':
        case 'info':
        case 'error':
        case 'warn':
          break;
        default:
          type = 'log';
      }

      console[type]('  \033[90m%s :\033[0m \033[36m%s\033[0m', key, val);
    }
  };

  var coffeeError = function(err) {
    log("COFFEE " + err.name, err.message, 'error');
  };

  // Once option
  options.once = options.once || false;

  // Source dir required
  var src = options.src;
  if (!src) { throw new Error('coffee.middleware() requires "src" directory'); }

  // Default dest dir to source
  var dest = options.dest ? options.dest : src;

  // Default compile callback
  options.compile = options.compile || coffee.compile;

  // Middleware
  return function(req, res, next) {
    if ('GET' != req.method.toUpperCase() && 'HEAD' != req.method.toUpperCase()) { return next(); }

    var pathname = url.parse(req.url).pathname;

    // Only handle the matching files
    if (regex.handle.test(pathname)) {
      if (options.prefix && 0 === pathname.indexOf(options.prefix)) {
        pathname = pathname.substring(options.prefix.length);
      }

      var jsPath = path.join(dest, pathname);
      var coffeePath = path.join(src, pathname.replace('.js', '.coffee'));

      log('source', coffeePath);
      log('dest', jsPath);

      // Ignore ENOENT to fall through as 404
      var error = function(err) {
        return next('ENOENT' == err.code ? null : err);
      };

      // Compile to jsPath
      var compile = function() {
        log('read', coffeePath);

        fs.readFile(coffeePath, 'utf8', function(err, str){
          if (err) { return error(err); }

          try {
            var compiled = options.compile(str, {filename: coffeePath});
            log('render', coffeePath);

            mkdirp(path.dirname(jsPath), 0777, function(err){
              if (err) return error(err);
              fs.writeFile(jsPath, compiled, 'utf8', next);
            });

          } catch (err) {
            coffeeError(err);

            return next(err);
          }
        });
      };

      // Force
      if (options.force) { return compile(); }

      // Only check/recompile if it has not been done at before
      if (options.once) { return next(); }

      // Compare mtimes
      fs.stat(coffeePath, function(err, coffeeStats){
        if (err) { return error(err); }

        fs.stat(jsPath, function(err, jsStats){
          // js has not been compiled, compile it!
          if (err) {
            if ('ENOENT' == err.code) {
              log('not found', jsPath);

              // No js file found in dest
              return compile();
            } else {
              return next(err);
            }
          } else if (coffeeStats.mtime > jsStats.mtime) {
            // Source has changed, compile it
            log('modified', jsPath);

            return compile();
          }
        });
      });
    } else {
      return next();
    }
  };
};
